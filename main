game:GetService('StarterGui'):SetCore('SendNotification', {
    Title = 'Made by mikawexs',
    Text = 'https://t.me/mikawexsWW'
})

if getgenv().mikawexsAntiDoubleInject == true then return end
getgenv().mikawexsAntiDoubleInject = true

if not game.IsLoaded(game) then game.Loaded:Wait() end

local Workspace = game:GetService('Workspace')
local Players = game:GetService('Players')
local TweenService = game:GetService('TweenService')
local RunService = game:GetService('RunService')
local InputService = game:GetService('UserInputService')
local Stats = game:GetService('Stats')

local Camera = Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local Target
local IsToggled = false
local TInfo
local Tween
local IsTyping = false
local Cycle
local DeltaTime

local PreviousPosition
local CurrentPosition

local MinAllowedHealth
local MaxAllowedDistance

local Random = math.random
local HugeInt = math.huge

InputService.TextBoxFocused:Connect(function() IsTyping = true end)
InputService.TextBoxFocusReleased:Connect(function() IsTyping = false end)

RunService.RenderStepped:Connect(function(d)
    DeltaTime = d
end)

RunService.RenderStepped:Connect(function()
    if getgenv().mikawexs.Checks.HealthCheck == true then
        if Target and Target.Character and Target.Character:FindFirstChildOfClass('Humanoid') then
            local Humanoid = Target.Character:FindFirstChildOfClass('Humanoid')
            if Humanoid.Health and Humanoid.Health < 1 then
                if Cycle then Cycle:Disconnect() end
                if Tween then Tween:Cancel() end
                Target = nil
                IsToggled = false
            end
        end
        if Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
            local LocalHumanoid = LocalPlayer.Character.Humanoid
            if LocalHumanoid.Health and LocalHumanoid.Health < 1 then
                if Cycle then Cycle:Disconnect() end
                if Tween then Tween:Cancel() end
                Target = nil
                IsToggled = false
            end
        end
    end

    if getgenv().mikawexs.Checks.DistanceCheck.Enabled == true then
        if Target and Target.Character and Target.Character:FindFirstChild('HumanoidRootPart') and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') then
            local RootPart = Target.Character:FindFirstChild('HumanoidRootPart')
            local LocalRootPart = LocalPlayer.Character:FindFirstChild('HumanoidRootPart')
            local Magnitude = (RootPart.Position - LocalRootPart.Position).Magnitude
            if Magnitude > getgenv().mikawexs.Checks.DistanceCheck.Value then
                if Cycle then Cycle:Disconnect() end
                if Tween then Tween:Cancel() end
                Target = nil
                IsToggled = false
            end
        end
    end
    if getgenv().mikawexs.Misc.FOV.UntargetWhenOutOfFOV == true then
        if Target ~= nil and Target.Character ~= nil and Target.Character:FindFirstChild(getgenv().mikawexs.General.BodyPart) then
            local ScreenPos, Visible = Camera:WorldToScreenPoint(Target.Character:FindFirstChild(getgenv().mikawexs.General.BodyPart).Position)
            if Visible then
                ScreenPos = Vector2.new(ScreenPos.X, ScreenPos.Y)
                local MousePos = Vector2.new(Mouse.X, Mouse.Y)
                local Magnitude2D = (ScreenPos - MousePos).Magnitude
                if Magnitude2D > getgenv().mikawexs.Misc.FOV.Radius then
                    if Cycle then Cycle:Disconnect() end
                    if Tween then Tween:Cancel() end
                    Target = nil
                    IsToggled = false
                end
            else
                if Cycle then Cycle:Disconnect() end
                if Tween then Tween:Cancel() end
                Target = nil
                IsToggled = false
            end
        end
    end
end)

local function WallCheck(Origin, Direction, IgnoreTableOfInstances)
    if getgenv().mikawexs.Checks.WallCheck.Enabled == true then
        local OriginRay = Origin.CFrame.Position
        local DirectionRay = Direction.CFrame.Position - Origin.CFrame.Position
        local RayParams = RaycastParams.new()
        RayParams.IgnoreWater = true
        RayParams.FilterType = Enum.RaycastFilterType.Exclude

        RayParams.FilterDescendantsInstances = IgnoreTableOfInstances
        local Result = Workspace:Raycast(OriginRay, DirectionRay, RayParams)
        if Result then
            if Result.Instance then -- If theres part on the ray
                if Result.Instance == Direction then -- If part is a B or is a Accessory or Tool
                    return false
                else
                    return true
                end
            else
                return false
            end
        else
            return false
        end
    else
        return false
    end
end

local function MidCycleWallCheck(ObjectToCheck)
    if getgenv().mikawexs.Checks.WallCheck.UntargetWhenTargetGoesBehindWall == true then

        local IgnoreList = {}

        for _, Player in pairs(Players:GetPlayers()) do
            if Player.Character ~= nil then
                for _, Instance in pairs(Player.Character:GetDescendants()) do
                    table.insert(IgnoreList, Instance)
                end
            end
        end

        local WallCheckResult = WallCheck(Camera, ObjectToCheck, IgnoreList)

        if WallCheckResult == true then
            return true
        else
            return false
        end
    else
        return false
    end
end

local function TeamCheck(Player)
    if getgenv().mikawexs.Checks.TeamCheck == true then
        local LocalTeam = LocalPlayer.Team
        local PlayerTeam = Player.Team
        if LocalTeam ~= nil and PlayerTeam ~= nil and LocalTeam == PlayerTeam then
            return true
        else
            return false
        end
    else
        return false
    end
end

local function GetTarget()
    local ClosestPLR, ClosestDistance = nil, nil
    if getgenv().mikawexs.Misc.FOV.Enabled == true then
        ClosestDistance = getgenv().mikawexs.Misc.FOV.Radius
    else
        ClosestDistance = HugeInt
    end
    for _, Plr in pairs(Players:GetPlayers()) do
        if Plr ~= LocalPlayer and Plr.Character ~= nil and Plr.Character:FindFirstChild('HumanoidRootPart') ~= nil and Plr.Character:FindFirstChild(getgenv().mikawexs.General.BodyPart) ~= nil and LocalPlayer.Character ~= nil and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') ~= nil then
            local ScreenPos, Visible = Camera:WorldToScreenPoint(Plr.Character:FindFirstChild(getgenv().mikawexs.General.BodyPart).Position)

            if getgenv().mikawexs.Checks.DistanceCheck.Enabled == true then MaxAllowedDistance = getgenv().mikawexs.Checks.DistanceCheck.Value else MaxAllowedDistance = math.huge end
            if getgenv().mikawexs.Checks.HealthCheck == true then MinAllowedHealth = 1 else MinAllowedHealth = 0 end

            local RootPart = Plr.Character:FindFirstChild('HumanoidRootPart')
            local LocalRootPart = LocalPlayer.Character:FindFirstChild('HumanoidRootPart')
            local Magnitude3D = (RootPart.Position - LocalRootPart.Position).Magnitude

            local Humanoid = Plr.Character:FindFirstChildOfClass('Humanoid')
            local Health = Humanoid.Health

            local LocalPlayerDescendants = LocalPlayer.Character:GetDescendants()
            local IgnoreModelDescendants = Plr.Character:GetDescendants()
            local InstancesToIgnore = {}
            for _, Value in pairs(LocalPlayerDescendants) do
                table.insert(InstancesToIgnore, Value)
            end
            for _, Value in pairs(IgnoreModelDescendants) do
                table.insert(InstancesToIgnore, Value)
            end
            local ToPart = Plr.Character:FindFirstChild(getgenv().mikawexs.General.BodyPart)
            local WallCheckResult = WallCheck(Camera, ToPart, InstancesToIgnore)

            local TeamCheckResult = TeamCheck(Plr)

            if Visible and not WallCheckResult and not TeamCheckResult and Magnitude3D < MaxAllowedDistance and Health > MinAllowedHealth then
                ScreenPos = Vector2.new(ScreenPos.X, ScreenPos.Y)
                local MousePos = Vector2.new(Mouse.X, Mouse.Y)
                local Magnitude2D = (ScreenPos - MousePos).Magnitude
                if Magnitude2D < ClosestDistance then
                    ClosestDistance = Magnitude2D
                    ClosestPLR = Plr
                end
            end
        end
    end
    return ClosestPLR
end

local function GetVelocity(Target)
    local Velocity
    if getgenv().mikawexs.Resolver.Enabled == true then
        if getgenv().mikawexs.Resolver.Method == 'MoveDirection' then
            if Target.Character and Target.Character:FindFirstChildOfClass('Humanoid') ~= nil then
                Velocity = Target.Character:FindFirstChildOfClass('Humanoid').MoveDirection * Target.Character:FindFirstChildOfClass('Humanoid').WalkSpeed
            else
                Velocity = Vector3.new(0,0,0)
            end
        elseif getgenv().mikawexs.Resolver.Method == 'RecalcVelocity' then
            if Target.Character and Target.Character:FindFirstChild('HumanoidRootPart') ~= nil then
                CurrentPosition = Target.Character:FindFirstChild('HumanoidRootPart').Position
                if PreviousPosition then
                    Velocity = (CurrentPosition - PreviousPosition) / DeltaTime
                else
                    Velocity = Vector3.new(0,0,0)
                end
                PreviousPosition = CurrentPosition
            else
                Velocity = Vector3.new(0,0,0)
            end
        else
            warn('Invalid Resolver Method')
            Velocity = Vector3.new(0,0,0)
        end
    else
        if Target.Character and Target.Character:FindFirstChild('HumanoidRootPart') ~= nil then
            Velocity = Target.Character:FindFirstChild('HumanoidRootPart').Velocity
        else
            Velocity = Vector3.new(0,0,0)
        end
    end
    return Velocity     
end

local function Main()
    Target = GetTarget()
    if Target ~= nil then
        Cycle = RunService.RenderStepped:Connect(function()
            if Target ~= nil and Target.Character ~= nil and Target.Character:FindFirstChild('HumanoidRootPart') and Target.Character:FindFirstChild(getgenv().mikawexs.General.BodyPart) ~= nil then
                local MidCycleWallCheckResult = MidCycleWallCheck(Target.Character[getgenv().mikawexs.General.BodyPart])
                
                if MidCycleWallCheckResult == true then
                    if Cycle then Cycle:Disconnect() end
                    if Tween then Tween:Cancel() end
                    Target = nil
                    IsToggled = not IsToggled
                end
                local ShakeX, ShakeY, ShakeZ
                if getgenv().mikawexs.Misc.Shake.Enabled == true then
                    ShakeX, ShakeY, ShakeZ = Random(-getgenv().mikawexs.Misc.Shake.X * 1000, getgenv().mikawexs.Misc.Shake.X * 1000) / 1000, Random(-getgenv().mikawexs.Misc.Shake.Y * 1000, getgenv().mikawexs.Misc.Shake.Y * 1000) / 1000, Random(-getgenv().mikawexs.Misc.Shake.X * 1000, getgenv().mikawexs.Misc.Shake.X * 1000) / 1000
                else
                    ShakeX, ShakeY, ShakeZ = 0, 0, 0
                end

                local CompensatorValue = 0
                if getgenv().mikawexs.Smoothness.Enabled == true then
                    TInfo = TweenInfo.new(getgenv().mikawexs.Smoothness.Value, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0)
                    if getgenv().mikawexs.Smoothness.SmoothnessCompensator == true then
                        CompensatorValue = getgenv().mikawexs.Smoothness.Value / 2
                    else
                        CompensatorValue = 0
                    end
                else
                    TInfo = TweenInfo.new(0, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0)
                end

                local Offset = Vector3.new(
                    Target.Character:FindFirstChild('HumanoidRootPart').CFrame.XVector * getgenv().mikawexs.General.Offset.X,
                    Target.Character:FindFirstChild('HumanoidRootPart').CFrame.YVector * getgenv().mikawexs.General.Offset.Y,
                    Target.Character:FindFirstChild('HumanoidRootPart').CFrame.ZVector * getgenv().mikawexs.General.Offset.Z
                )

                local LookAt
                local Velocity = GetVelocity(Target)
                if getgenv().mikawexs.Prediction.Enabled == true then
                    if getgenv().mikawexs.Prediction.Method == 'Normal' then
                        LookAt = CFrame.lookAt(Camera.CFrame.Position, Target.Character:FindFirstChild(getgenv().mikawexs.General.BodyPart).Position
                            + Vector3.new(
                                Velocity.X * getgenv().mikawexs.Prediction.Normal.X,
                                Velocity.Y * getgenv().mikawexs.Prediction.Normal.Y,
                                Velocity.Z * getgenv().mikawexs.Prediction.Normal.X
                            )
                            + Vector3.new(
                                ShakeX, ShakeY, ShakeZ
                            )
                            + Offset
                            + Velocity * CompensatorValue
                        )
                    elseif getgenv().mikawexs.Prediction.Method == 'AutoPred' then
                        local Ping = tonumber(string.format('%.3f', Stats.Network.ServerStatsItem['Data Ping']:GetValue()))
                        LookAt = CFrame.lookAt(Camera.CFrame.Position, Target.Character:FindFirstChild(getgenv().mikawexs.General.BodyPart).Position
                            + Vector3.new(
                                Velocity.X * (Ping * getgenv().mikawexs.Prediction.AutoPred.X),
                                Velocity.Y * (Ping * getgenv().mikawexs.Prediction.AutoPred.Y),
                                Velocity.Z * (Ping * getgenv().mikawexs.Prediction.AutoPred.X)
                            )
                            + Vector3.new(
                                ShakeX, ShakeY, ShakeZ
                            )
                            + Offset
                            + Velocity * CompensatorValue
                        )
                    else
                        warn('Invalid prediction method')
                        if Tween then Tween:Cancel() end
                        if Cycle then Cycle:Disconnect() end
                        Target = nil
                        IsToggled = false
                    end
                else
                    LookAt = CFrame.lookAt(Camera.CFrame.Position, Target.Character:FindFirstChild(getgenv().mikawexs.General.BodyPart).Position
                        + Vector3.new(ShakeX, ShakeY, ShakeZ) + Offset
                        + Velocity * CompensatorValue
                    )
                end
                Tween = TweenService:Create(Camera, TInfo, {CFrame = LookAt})
                Tween:Play()
            else
                if Tween then Tween:Cancel() end
                if Cycle then Cycle:Disconnect() end
                Target = nil
                IsToggled = false
            end
        end)
    end
end

Mouse.KeyDown:Connect(function(Key)
    if IsTyping then return end
    Key = Key:lower()
    if Key == getgenv().mikawexs.General.Bind then
        if not IsToggled then
            Main()
            IsToggled = true
        elseif IsToggled then
            if Tween then Tween:Cancel() end
            if Cycle then Cycle:Disconnect() end
            Target = nil
            IsToggled = false
        end
    end
end)
